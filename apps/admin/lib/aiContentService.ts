import { prisma } from '@/lib/prisma';

export interface AIContentRequest {
  pageData: {
    id: string;
    slug: string;
    insuranceType: string;
    state?: string;
    city?: string;
    customData?: any;
  };
  sections: ('intro' | 'requirements' | 'faqs' | 'tips')[];
  model?: string;
}

export interface AIContentResponse {
  success: boolean;
  content?: {
    intro?: string;
    requirements?: string;
    faqs?: Array<{ question: string; answer: string }>;
    tips?: string[];
  };
  error?: string;
  tokensUsed?: number;
  cost?: number;
}

// OpenRouter API client with multi-account rotation
export class OpenRouterService {
  private static currentProviderIndex = 0;

  /**
   * Get next available AI provider (round-robin with budget check)
   */
  static async getNextProvider() {
    // Get all active providers and filter in JavaScript for budget comparison
    const providers = await prisma.aIProvider.findMany({
      where: {
        isActive: true
      },
      orderBy: { priority: 'asc' }
    });

    // Filter providers that have budget available
    const availableProviders = providers.filter((provider: any) => {
      // No budget limit
      if (provider.totalBudget === null) return true;
      // Has budget remaining
      return provider.usedBudget < provider.totalBudget;
    });

    if (availableProviders.length === 0) {
      throw new Error('No AI providers available. Please add API keys in settings.');
    }

    // Round-robin selection
    const provider = availableProviders[this.currentProviderIndex % availableProviders.length];
    this.currentProviderIndex = (this.currentProviderIndex + 1) % availableProviders.length;

    return provider;
  }

  /**
   * Generate AI content for a page
   */
  static async generateContent(request: AIContentRequest): Promise<AIContentResponse> {
    const provider = await this.getNextProvider();

    try {
      const prompt = this.buildPrompt(request);

      const response = await fetch(provider.apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${provider.apiKey}`,
          'HTTP-Referer': 'https://myinsurancebuddies.com',
          'X-Title': 'MyInsuranceBuddies Content Generator'
        },
        body: JSON.stringify({
          model: request.model || provider.preferredModel,
          messages: [
            {
              role: 'system',
              content: 'You are a professional insurance content writer. Create unique, SEO-optimized, and locally-relevant content for insurance pages. Write in a helpful, professional tone. Always include specific local details when available.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.7,
          max_tokens: provider.maxTokensPerRequest,
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));

        // Handle rate limit gracefully - STOP, don't crash
        if (response.status === 429) {
          return {
            success: false,
            error: 'Rate limit reached. Wait a few minutes or add more API accounts.',
            tokensUsed: 0,
            cost: 0
          };
        }

        // Handle insufficient credits
        if (response.status === 402) {
          return {
            success: false,
            error: 'Insufficient credits. Add more credits or switch to free model.',
            tokensUsed: 0,
            cost: 0
          };
        }

        // Handle other errors gracefully
        return {
          success: false,
          error: errorData.error?.message || `API error ${response.status}`,
          tokensUsed: 0,
          cost: 0
        };
      }

      const data = await response.json();

      // Parse response
      const contentText = data.choices?.[0]?.message?.content;
      if (!contentText) {
        return {
          success: false,
          error: 'No content generated by AI model',
          tokensUsed: 0,
          cost: 0
        };
      }

      // Extract structured content
      const content = this.parseAIResponse(contentText, request.sections);

      // Track usage
      const tokensUsed = data.usage?.total_tokens || 0;
      const cost = this.calculateCost(tokensUsed, request.model || provider.preferredModel);

      await this.trackUsage(provider.id, tokensUsed, cost);

      return {
        success: true,
        content,
        tokensUsed,
        cost
      };
    } catch (error: any) {
      console.error('AI generation error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Build prompt based on page data and requested sections
   */
  private static buildPrompt(request: AIContentRequest): string {
    const { pageData, sections } = request;
    const location = pageData.city
      ? `${pageData.city}, ${pageData.state}`
      : pageData.state || 'the United States';

    let prompt = `Generate unique content for a ${pageData.insuranceType} page for ${location}.\n\n`;

    // Add context from customData if available
    if (pageData.customData) {
      const { avg_premium, min_coverage, population } = pageData.customData;
      prompt += `Context:\n`;
      if (avg_premium) prompt += `- Average premium: ${avg_premium}\n`;
      if (min_coverage) prompt += `- Minimum coverage: ${JSON.stringify(min_coverage)}\n`;
      if (population) prompt += `- Population: ${population}\n`;
      prompt += `\n`;
    }

    prompt += `Generate the following sections in JSON format:\n\n`;

    if (sections.includes('intro')) {
      prompt += `1. "intro": A 2-3 paragraph introduction about ${pageData.insuranceType} in ${location}. Include local context, why it's important, and what residents should know. Make it unique and specific to this location.\n\n`;
    }

    if (sections.includes('requirements')) {
      prompt += `2. "requirements": A detailed paragraph about ${pageData.insuranceType} requirements in ${location}. Include state-specific laws, minimum coverage, and compliance details.\n\n`;
    }

    if (sections.includes('faqs')) {
      prompt += `3. "faqs": An array of 5-7 location-specific FAQs. Each FAQ should have "question" and "answer" fields. Focus on questions specific to ${location}.\n\n`;
    }

    if (sections.includes('tips')) {
      prompt += `4. "tips": An array of 5-8 practical tips for getting the best ${pageData.insuranceType} in ${location}. Include local considerations, discounts, and money-saving strategies.\n\n`;
    }

    prompt += `\nIMPORTANT: Return ONLY a valid JSON object with the requested fields. No markdown, no code blocks, just pure JSON.`;

    return prompt;
  }

  /**
   * Parse AI response into structured content
   */
  private static parseAIResponse(responseText: string, sections: string[]): any {
    try {
      // Remove markdown code blocks if present
      let cleaned = responseText.trim();
      cleaned = cleaned.replace(/^```json\n?/i, '').replace(/\n?```$/i, '');
      cleaned = cleaned.trim();

      const parsed = JSON.parse(cleaned);

      // Validate required sections
      const content: any = {};

      if (sections.includes('intro') && parsed.intro) {
        content.intro = parsed.intro;
      }

      if (sections.includes('requirements') && parsed.requirements) {
        content.requirements = parsed.requirements;
      }

      if (sections.includes('faqs') && Array.isArray(parsed.faqs)) {
        content.faqs = parsed.faqs;
      }

      if (sections.includes('tips') && Array.isArray(parsed.tips)) {
        content.tips = parsed.tips;
      }

      return content;
    } catch (error) {
      console.error('Failed to parse AI response:', error);
      console.error('Response text:', responseText);

      // Fallback: try to extract sections manually
      return this.fallbackParse(responseText, sections);
    }
  }

  /**
   * Fallback parsing if JSON fails
   */
  private static fallbackParse(text: string, sections: string[]): any {
    const content: any = {};

    // Try to extract intro
    if (sections.includes('intro')) {
      const introMatch = text.match(/"intro":\s*"([^"]+)"/);
      if (introMatch) content.intro = introMatch[1];
    }

    // Try to extract requirements
    if (sections.includes('requirements')) {
      const reqMatch = text.match(/"requirements":\s*"([^"]+)"/);
      if (reqMatch) content.requirements = reqMatch[1];
    }

    return content;
  }

  /**
   * Calculate cost based on tokens and model
   */
  private static calculateCost(tokens: number, model: string): number {
    // OpenRouter pricing (approximate - updated Jan 2026)
    const pricing: Record<string, number> = {
      // FREE MODELS (Xiaomi, DeepSeek, etc.)
      'xiaomi/mimo-v2-flash': 0.00, // FREE - HIGH QUALITY (deprecating Jan 26!)
      'deepseek/deepseek-chat': 0.00, // FREE
      'deepseek/deepseek-r1': 0.00, // FREE (Xiaomi's DeepSeek model)
      'qwen/qwen-2.5-72b-instruct': 0.00, // FREE
      'microsoft/phi-3-medium-128k-instruct': 0.00, // FREE
      'meta-llama/llama-3.2-3b-instruct': 0.00, // FREE

      // ULTRA CHEAP MODELS (<$0.10/M tokens)
      'google/gemini-flash-1.5': 0.075 / 1_000_000, // $0.075 per 1M
      'google/gemini-2.0-flash-exp': 0.00, // FREE (experimental)
      'openai/gpt-4o-mini': 0.15 / 1_000_000,
      'deepseek/deepseek-coder': 0.00, // FREE

      // CHEAP MODELS
      'anthropic/claude-haiku': 0.25 / 1_000_000,
      'anthropic/claude-haiku-3.5': 0.80 / 1_000_000,
      'openai/gpt-3.5-turbo': 0.50 / 1_000_000,
      'meta-llama/llama-3.1-70b-instruct': 0.20 / 1_000_000,
    };

    const rate = pricing[model.toLowerCase()] || pricing[model] || 0.00; // Default to free
    return tokens * rate;
  }

  /**
   * Track provider usage
   */
  private static async trackUsage(providerId: string, tokens: number, cost: number) {
    await prisma.aIProvider.update({
      where: { id: providerId },
      data: {
        usedBudget: { increment: cost },
        requestCount: { increment: 1 },
        lastUsedAt: new Date()
      }
    });
  }
}

/**
 * Batch process multiple pages
 */
export async function batchGenerateContent(
  pageIds: string[],
  sections: ('intro' | 'requirements' | 'faqs' | 'tips')[],
  options: {
    batchSize?: number;
    delayBetweenBatches?: number;
    model?: string;
    onProgress?: (processed: number, total: number) => void;
  } = {}
): Promise<{ successful: number; failed: number; errors: any[] }> {
  const {
    batchSize = 10,
    delayBetweenBatches = 1000,
    model,
    onProgress
  } = options;

  const results = {
    successful: 0,
    failed: 0,
    errors: [] as any[],
    stopped: false,
    stopReason: ''
  };

  // Process in batches
  for (let i = 0; i < pageIds.length; i += batchSize) {
    const batch = pageIds.slice(i, i + batchSize);

    // Fetch page data
    const pages = await prisma.page.findMany({
      where: { id: { in: batch } },
      include: {
        insuranceType: true,
        state: true,
        city: true
      }
    });

    // Process batch in parallel
    const promises = pages.map(async (page) => {
      try {
        const response = await OpenRouterService.generateContent({
          pageData: {
            id: page.id,
            slug: page.slug,
            insuranceType: page.insuranceType?.name || 'Insurance',
            state: page.state?.name,
            city: page.city?.name,
            customData: page.customData
          },
          sections,
          model
        });

        if (response.success && response.content) {
          // Update page with AI content
          await prisma.page.update({
            where: { id: page.id },
            data: {
              aiGeneratedContent: response.content,
              aiGeneratedAt: new Date(),
              aiModel: model || 'xiaomi/mimo-v2-flash',
              isAiGenerated: true
            }
          });

          results.successful++;
        } else {
          // Check if it's a rate limit error
          if (response.error && response.error.includes('Rate limit')) {
            results.stopped = true;
            results.stopReason = 'RATE_LIMIT';
            results.errors.push({
              pageId: page.id,
              error: response.error,
              severity: 'CRITICAL'
            });
            // Don't count as failed, just stopped
            return; // Exit this promise early
          }

          results.failed++;
          results.errors.push({ pageId: page.id, error: response.error });
        }
      } catch (error: any) {
        results.failed++;
        results.errors.push({ pageId: page.id, error: error.message });
      }
    });

    await Promise.all(promises);

    // Check if we hit rate limit and should STOP
    if (results.stopped) {
      console.warn(`⚠️ Batch generation stopped due to: ${results.stopReason}`);
      break; // Exit the for loop immediately
    }

    // Progress callback
    if (onProgress) {
      onProgress(Math.min(i + batchSize, pageIds.length), pageIds.length);
    }

    // Delay between batches
    if (i + batchSize < pageIds.length) {
      await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
    }
  }

  return results;
}
